// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

var HdpMessage = exports.HdpMessage = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var StatRequest = exports.StatRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var StatResponse = exports.StatResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Stat = exports.Stat = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ReadDirRequest = exports.ReadDirRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var OpenRequest = exports.OpenRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var OpenResponse = exports.OpenResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ReadRequest = exports.ReadRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ReadResponse = exports.ReadResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ReadDirResponse = exports.ReadDirResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Dir = exports.Dir = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var CloseRequest = exports.CloseRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var CloseResponse = exports.CloseResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineHdpMessage()
defineStatRequest()
defineStatResponse()
defineStat()
defineReadDirRequest()
defineOpenRequest()
defineOpenResponse()
defineReadRequest()
defineReadResponse()
defineReadDirResponse()
defineDir()
defineCloseRequest()
defineCloseResponse()

function defineHdpMessage () {
  HdpMessage.encodingLength = encodingLength
  HdpMessage.encode = encode
  HdpMessage.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.readDirRequest) + +defined(obj.readDirResponse) + +defined(obj.statRequest) + +defined(obj.statResponse) + +defined(obj.openRequest) + +defined(obj.openResponse) + +defined(obj.readRequest) + +defined(obj.readResponse) + +defined(obj.closeRequest) + +defined(obj.closeResponse)) > 1) throw new Error("only one of the properties defined in oneof msg can be set")
    if (defined(obj.readDirRequest)) {
      var len = ReadDirRequest.encodingLength(obj.readDirRequest)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.readDirResponse)) {
      var len = ReadDirResponse.encodingLength(obj.readDirResponse)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.statRequest)) {
      var len = StatRequest.encodingLength(obj.statRequest)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.statResponse)) {
      var len = StatResponse.encodingLength(obj.statResponse)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.openRequest)) {
      var len = OpenRequest.encodingLength(obj.openRequest)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.openResponse)) {
      var len = OpenResponse.encodingLength(obj.openResponse)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.readRequest)) {
      var len = ReadRequest.encodingLength(obj.readRequest)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.readResponse)) {
      var len = ReadResponse.encodingLength(obj.readResponse)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.closeRequest)) {
      var len = CloseRequest.encodingLength(obj.closeRequest)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.closeResponse)) {
      var len = CloseResponse.encodingLength(obj.closeResponse)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.readDirRequest) + +defined(obj.readDirResponse) + +defined(obj.statRequest) + +defined(obj.statResponse) + +defined(obj.openRequest) + +defined(obj.openResponse) + +defined(obj.readRequest) + +defined(obj.readResponse) + +defined(obj.closeRequest) + +defined(obj.closeResponse)) > 1) throw new Error("only one of the properties defined in oneof msg can be set")
    if (defined(obj.readDirRequest)) {
      buf[offset++] = 10
      varint.encode(ReadDirRequest.encodingLength(obj.readDirRequest), buf, offset)
      offset += varint.encode.bytes
      ReadDirRequest.encode(obj.readDirRequest, buf, offset)
      offset += ReadDirRequest.encode.bytes
    }
    if (defined(obj.readDirResponse)) {
      buf[offset++] = 18
      varint.encode(ReadDirResponse.encodingLength(obj.readDirResponse), buf, offset)
      offset += varint.encode.bytes
      ReadDirResponse.encode(obj.readDirResponse, buf, offset)
      offset += ReadDirResponse.encode.bytes
    }
    if (defined(obj.statRequest)) {
      buf[offset++] = 26
      varint.encode(StatRequest.encodingLength(obj.statRequest), buf, offset)
      offset += varint.encode.bytes
      StatRequest.encode(obj.statRequest, buf, offset)
      offset += StatRequest.encode.bytes
    }
    if (defined(obj.statResponse)) {
      buf[offset++] = 34
      varint.encode(StatResponse.encodingLength(obj.statResponse), buf, offset)
      offset += varint.encode.bytes
      StatResponse.encode(obj.statResponse, buf, offset)
      offset += StatResponse.encode.bytes
    }
    if (defined(obj.openRequest)) {
      buf[offset++] = 42
      varint.encode(OpenRequest.encodingLength(obj.openRequest), buf, offset)
      offset += varint.encode.bytes
      OpenRequest.encode(obj.openRequest, buf, offset)
      offset += OpenRequest.encode.bytes
    }
    if (defined(obj.openResponse)) {
      buf[offset++] = 50
      varint.encode(OpenResponse.encodingLength(obj.openResponse), buf, offset)
      offset += varint.encode.bytes
      OpenResponse.encode(obj.openResponse, buf, offset)
      offset += OpenResponse.encode.bytes
    }
    if (defined(obj.readRequest)) {
      buf[offset++] = 58
      varint.encode(ReadRequest.encodingLength(obj.readRequest), buf, offset)
      offset += varint.encode.bytes
      ReadRequest.encode(obj.readRequest, buf, offset)
      offset += ReadRequest.encode.bytes
    }
    if (defined(obj.readResponse)) {
      buf[offset++] = 66
      varint.encode(ReadResponse.encodingLength(obj.readResponse), buf, offset)
      offset += varint.encode.bytes
      ReadResponse.encode(obj.readResponse, buf, offset)
      offset += ReadResponse.encode.bytes
    }
    if (defined(obj.closeRequest)) {
      buf[offset++] = 74
      varint.encode(CloseRequest.encodingLength(obj.closeRequest), buf, offset)
      offset += varint.encode.bytes
      CloseRequest.encode(obj.closeRequest, buf, offset)
      offset += CloseRequest.encode.bytes
    }
    if (defined(obj.closeResponse)) {
      buf[offset++] = 82
      varint.encode(CloseResponse.encodingLength(obj.closeResponse), buf, offset)
      offset += varint.encode.bytes
      CloseResponse.encode(obj.closeResponse, buf, offset)
      offset += CloseResponse.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      readDirRequest: null,
      readDirResponse: null,
      statRequest: null,
      statResponse: null,
      openRequest: null,
      openResponse: null,
      readRequest: null,
      readResponse: null,
      closeRequest: null,
      closeResponse: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.readDirRequest = ReadDirRequest.decode(buf, offset, offset + len)
        offset += ReadDirRequest.decode.bytes
        break
        case 2:
        delete obj.readDirRequest
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.readDirResponse = ReadDirResponse.decode(buf, offset, offset + len)
        offset += ReadDirResponse.decode.bytes
        break
        case 3:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statResponse
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.statRequest = StatRequest.decode(buf, offset, offset + len)
        offset += StatRequest.decode.bytes
        break
        case 4:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.statResponse = StatResponse.decode(buf, offset, offset + len)
        offset += StatResponse.decode.bytes
        break
        case 5:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openResponse
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.openRequest = OpenRequest.decode(buf, offset, offset + len)
        offset += OpenRequest.decode.bytes
        break
        case 6:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openRequest
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.openResponse = OpenResponse.decode(buf, offset, offset + len)
        offset += OpenResponse.decode.bytes
        break
        case 7:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readResponse
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.readRequest = ReadRequest.decode(buf, offset, offset + len)
        offset += ReadRequest.decode.bytes
        break
        case 8:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readRequest
        delete obj.closeRequest
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.readResponse = ReadResponse.decode(buf, offset, offset + len)
        offset += ReadResponse.decode.bytes
        break
        case 9:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeResponse
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.closeRequest = CloseRequest.decode(buf, offset, offset + len)
        offset += CloseRequest.decode.bytes
        break
        case 10:
        delete obj.readDirRequest
        delete obj.readDirResponse
        delete obj.statRequest
        delete obj.statResponse
        delete obj.openRequest
        delete obj.openResponse
        delete obj.readRequest
        delete obj.readResponse
        delete obj.closeRequest
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.closeResponse = CloseResponse.decode(buf, offset, offset + len)
        offset += CloseResponse.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineStatRequest () {
  StatRequest.encodingLength = encodingLength
  StatRequest.encode = encode
  StatRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.path)) throw new Error("path is required")
    var len = encodings.string.encodingLength(obj.path)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.path)) throw new Error("path is required")
    buf[offset++] = 10
    encodings.string.encode(obj.path, buf, offset)
    offset += encodings.string.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      path: ""
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.path = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineStatResponse () {
  StatResponse.encodingLength = encodingLength
  StatResponse.encode = encode
  StatResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.err) + +defined(obj.stat)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (!defined(obj.path)) throw new Error("path is required")
    var len = encodings.string.encodingLength(obj.path)
    length += 1 + len
    if (defined(obj.err)) {
      var len = encodings.varint.encodingLength(obj.err)
      length += 1 + len
    }
    if (defined(obj.stat)) {
      var len = Stat.encodingLength(obj.stat)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.err) + +defined(obj.stat)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (!defined(obj.path)) throw new Error("path is required")
    buf[offset++] = 10
    encodings.string.encode(obj.path, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.err)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.err, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.stat)) {
      buf[offset++] = 26
      varint.encode(Stat.encodingLength(obj.stat), buf, offset)
      offset += varint.encode.bytes
      Stat.encode(obj.stat, buf, offset)
      offset += Stat.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      path: "",
      err: 0,
      stat: null
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.path = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        delete obj.stat
        obj.err = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 3:
        delete obj.err
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.stat = Stat.decode(buf, offset, offset + len)
        offset += Stat.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineStat () {
  Stat.encodingLength = encodingLength
  Stat.encode = encode
  Stat.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.size)) {
      var len = encodings.varint.encodingLength(obj.size)
      length += 1 + len
    }
    if (defined(obj.atime)) {
      var len = encodings.varint.encodingLength(obj.atime)
      length += 1 + len
    }
    if (defined(obj.mtime)) {
      var len = encodings.varint.encodingLength(obj.mtime)
      length += 1 + len
    }
    if (defined(obj.ctime)) {
      var len = encodings.varint.encodingLength(obj.ctime)
      length += 1 + len
    }
    if (defined(obj.mode)) {
      var len = encodings.varint.encodingLength(obj.mode)
      length += 1 + len
    }
    if (defined(obj.dev)) {
      var len = encodings.varint.encodingLength(obj.dev)
      length += 1 + len
    }
    if (defined(obj.ino)) {
      var len = encodings.varint.encodingLength(obj.ino)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.size)) {
      buf[offset++] = 8
      encodings.varint.encode(obj.size, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.atime)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.atime, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.mtime)) {
      buf[offset++] = 24
      encodings.varint.encode(obj.mtime, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.ctime)) {
      buf[offset++] = 32
      encodings.varint.encode(obj.ctime, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.mode)) {
      buf[offset++] = 40
      encodings.varint.encode(obj.mode, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.dev)) {
      buf[offset++] = 48
      encodings.varint.encode(obj.dev, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.ino)) {
      buf[offset++] = 56
      encodings.varint.encode(obj.ino, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      size: 0,
      atime: 0,
      mtime: 0,
      ctime: 0,
      mode: 0,
      dev: 0,
      ino: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.size = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 2:
        obj.atime = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 3:
        obj.mtime = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 4:
        obj.ctime = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 5:
        obj.mode = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 6:
        obj.dev = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 7:
        obj.ino = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineReadDirRequest () {
  ReadDirRequest.encodingLength = encodingLength
  ReadDirRequest.encode = encode
  ReadDirRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.path)) throw new Error("path is required")
    var len = encodings.string.encodingLength(obj.path)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.path)) throw new Error("path is required")
    buf[offset++] = 10
    encodings.string.encode(obj.path, buf, offset)
    offset += encodings.string.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      path: ""
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.path = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineOpenRequest () {
  OpenRequest.encodingLength = encodingLength
  OpenRequest.encode = encode
  OpenRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.path)) throw new Error("path is required")
    var len = encodings.string.encodingLength(obj.path)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.path)) throw new Error("path is required")
    buf[offset++] = 10
    encodings.string.encode(obj.path, buf, offset)
    offset += encodings.string.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      path: ""
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.path = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineOpenResponse () {
  OpenResponse.encodingLength = encodingLength
  OpenResponse.encode = encode
  OpenResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.err) + +defined(obj.fd)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (!defined(obj.path)) throw new Error("path is required")
    var len = encodings.string.encodingLength(obj.path)
    length += 1 + len
    if (defined(obj.err)) {
      var len = encodings.varint.encodingLength(obj.err)
      length += 1 + len
    }
    if (defined(obj.fd)) {
      var len = encodings.varint.encodingLength(obj.fd)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.err) + +defined(obj.fd)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (!defined(obj.path)) throw new Error("path is required")
    buf[offset++] = 10
    encodings.string.encode(obj.path, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.err)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.err, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.fd)) {
      buf[offset++] = 24
      encodings.varint.encode(obj.fd, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      path: "",
      err: 0,
      fd: 0
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.path = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        delete obj.fd
        obj.err = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 3:
        delete obj.err
        obj.fd = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineReadRequest () {
  ReadRequest.encodingLength = encodingLength
  ReadRequest.encode = encode
  ReadRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.fd)) throw new Error("fd is required")
    var len = encodings.varint.encodingLength(obj.fd)
    length += 1 + len
    if (!defined(obj.len)) throw new Error("len is required")
    var len = encodings.varint.encodingLength(obj.len)
    length += 1 + len
    if (!defined(obj.pos)) throw new Error("pos is required")
    var len = encodings.varint.encodingLength(obj.pos)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.fd)) throw new Error("fd is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.fd, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.len)) throw new Error("len is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.len, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.pos)) throw new Error("pos is required")
    buf[offset++] = 24
    encodings.varint.encode(obj.pos, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      fd: 0,
      len: 0,
      pos: 0
    }
    var found0 = false
    var found1 = false
    var found2 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1 || !found2) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.fd = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.len = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        case 3:
        obj.pos = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found2 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineReadResponse () {
  ReadResponse.encodingLength = encodingLength
  ReadResponse.encode = encode
  ReadResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.err) + +defined(obj.data)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (!defined(obj.fd)) throw new Error("fd is required")
    var len = encodings.varint.encodingLength(obj.fd)
    length += 1 + len
    if (!defined(obj.len)) throw new Error("len is required")
    var len = encodings.varint.encodingLength(obj.len)
    length += 1 + len
    if (!defined(obj.pos)) throw new Error("pos is required")
    var len = encodings.varint.encodingLength(obj.pos)
    length += 1 + len
    if (defined(obj.err)) {
      var len = encodings.varint.encodingLength(obj.err)
      length += 1 + len
    }
    if (defined(obj.data)) {
      var len = encodings.bytes.encodingLength(obj.data)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.err) + +defined(obj.data)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (!defined(obj.fd)) throw new Error("fd is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.fd, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.len)) throw new Error("len is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.len, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.pos)) throw new Error("pos is required")
    buf[offset++] = 24
    encodings.varint.encode(obj.pos, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.err)) {
      buf[offset++] = 32
      encodings.varint.encode(obj.err, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.data)) {
      buf[offset++] = 42
      encodings.bytes.encode(obj.data, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      fd: 0,
      len: 0,
      pos: 0,
      err: 0,
      data: null
    }
    var found0 = false
    var found1 = false
    var found2 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1 || !found2) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.fd = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.len = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        case 3:
        obj.pos = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found2 = true
        break
        case 4:
        delete obj.data
        obj.err = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 5:
        delete obj.err
        obj.data = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineReadDirResponse () {
  ReadDirResponse.encodingLength = encodingLength
  ReadDirResponse.encode = encode
  ReadDirResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.err) + +defined(obj.dir)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (defined(obj.path)) {
      var len = encodings.string.encodingLength(obj.path)
      length += 1 + len
    }
    if (defined(obj.err)) {
      var len = encodings.varint.encodingLength(obj.err)
      length += 1 + len
    }
    if (defined(obj.dir)) {
      var len = Dir.encodingLength(obj.dir)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.err) + +defined(obj.dir)) > 1) throw new Error("only one of the properties defined in oneof response can be set")
    if (defined(obj.path)) {
      buf[offset++] = 10
      encodings.string.encode(obj.path, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.err)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.err, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.dir)) {
      buf[offset++] = 26
      varint.encode(Dir.encodingLength(obj.dir), buf, offset)
      offset += varint.encode.bytes
      Dir.encode(obj.dir, buf, offset)
      offset += Dir.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      path: "",
      err: 0,
      dir: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.path = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        delete obj.dir
        obj.err = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 3:
        delete obj.err
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.dir = Dir.decode(buf, offset, offset + len)
        offset += Dir.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineDir () {
  Dir.encodingLength = encodingLength
  Dir.encode = encode
  Dir.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.file)) {
      for (var i = 0; i < obj.file.length; i++) {
        if (!defined(obj.file[i])) continue
        var len = encodings.string.encodingLength(obj.file[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.file)) {
      for (var i = 0; i < obj.file.length; i++) {
        if (!defined(obj.file[i])) continue
        buf[offset++] = 10
        encodings.string.encode(obj.file[i], buf, offset)
        offset += encodings.string.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      file: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.file.push(encodings.string.decode(buf, offset))
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCloseRequest () {
  CloseRequest.encodingLength = encodingLength
  CloseRequest.encode = encode
  CloseRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.fd)) throw new Error("fd is required")
    var len = encodings.varint.encodingLength(obj.fd)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.fd)) throw new Error("fd is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.fd, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      fd: 0
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.fd = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCloseResponse () {
  CloseResponse.encodingLength = encodingLength
  CloseResponse.encode = encode
  CloseResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.fd)) throw new Error("fd is required")
    var len = encodings.varint.encodingLength(obj.fd)
    length += 1 + len
    if (defined(obj.err)) {
      var len = encodings.varint.encodingLength(obj.err)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.fd)) throw new Error("fd is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.fd, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.err)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.err, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      fd: 0,
      err: 0
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.fd = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.err = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
